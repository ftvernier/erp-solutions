-- =====================================================
-- SISTEMA DE MONITORAMENTO DE PERFORMANCE ORACLE
-- Detecta, registra e opcionalmente finaliza processos problemáticos
-- Autor: Fernando Vernier
-- GitHub: https://github.com/ftvernier/erp-solutions
-- =====================================================

-- =====================================================
-- 1. CRIAÇÃO DA TABELA DE LOG (EXECUTE APENAS UMA VEZ)
-- =====================================================

-- Verificar se a tabela já existe e criar se necessário
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM user_tables
    WHERE table_name = 'PERFORMANCE_MONITOR_LOG';
    
    IF v_count = 0 THEN
        EXECUTE IMMEDIATE '
        CREATE TABLE PERFORMANCE_MONITOR_LOG (
            LOG_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            EVENT_TIME TIMESTAMP DEFAULT SYSTIMESTAMP,
            EVENT_TYPE VARCHAR2(50) NOT NULL, -- ''LONG_TRANSACTION'', ''LONG_QUERY'', ''BLOCKING''
            SESSION_ID NUMBER NOT NULL,
            DURATION_MINUTES NUMBER(10,2) NULL,
            WAIT_SECONDS NUMBER(10,2) NULL,
            USERNAME VARCHAR2(128) NULL,
            HOSTNAME VARCHAR2(128) NULL,
            PROGRAM_NAME VARCHAR2(255) NULL,
            APPLICATION_TYPE VARCHAR2(50) NULL,
            COMMAND VARCHAR2(50) NULL,
            STATUS VARCHAR2(50) NULL,
            CPU_SECONDS NUMBER(10,2) NULL,
            BLOCK_GETS NUMBER NULL,
            CONSISTENT_GETS NUMBER NULL,
            PHYSICAL_READS NUMBER NULL,
            SQL_TEXT CLOB NULL,
            ACTION_TAKEN VARCHAR2(100) NULL, -- ''ALERTED'', ''AUTO_KILLED'', ''PROTECTED_USER'', ''BLOCKING_DETECTED''
            SERVER_NAME VARCHAR2(128) DEFAULT SYS_CONTEXT(''USERENV'', ''SERVER_HOST''),
            ERROR_MESSAGE VARCHAR2(500) NULL,
            BLOCKING_SESSION_ID NUMBER NULL,
            WAIT_EVENT VARCHAR2(64) NULL,
            MACHINE VARCHAR2(64) NULL,
            OSUSER VARCHAR2(30) NULL
        )';
        
        -- Criar índices para performance
        EXECUTE IMMEDIATE 'CREATE INDEX IX_PERFMON_EVENT_TIME ON PERFORMANCE_MONITOR_LOG (EVENT_TIME DESC)';
        EXECUTE IMMEDIATE 'CREATE INDEX IX_PERFMON_EVENT_TYPE ON PERFORMANCE_MONITOR_LOG (EVENT_TYPE)';
        EXECUTE IMMEDIATE 'CREATE INDEX IX_PERFMON_SESSION_ID ON PERFORMANCE_MONITOR_LOG (SESSION_ID)';
        
        DBMS_OUTPUT.PUT_LINE('✅ Tabela PERFORMANCE_MONITOR_LOG criada com sucesso!');
    ELSE
        DBMS_OUTPUT.PUT_LINE('ℹ️ Tabela PERFORMANCE_MONITOR_LOG já existe.');
    END IF;
END;
/

-- =====================================================
-- 2. PACKAGE DE MONITORAMENTO
-- =====================================================

-- Criar package specification
CREATE OR REPLACE PACKAGE PKG_PERFORMANCE_MONITOR AS
    
    -- Procedure principal de monitoramento
    PROCEDURE SP_MONITOR_PERFORMANCE_DB(
        p_transaction_threshold_minutes IN NUMBER DEFAULT 10,
        p_query_threshold_minutes IN NUMBER DEFAULT 10,
        p_auto_kill_threshold_minutes IN NUMBER DEFAULT 60,
        p_enable_transaction_alerts IN NUMBER DEFAULT 1,
        p_enable_blocking_alerts IN NUMBER DEFAULT 1,
        p_enable_long_query_alerts IN NUMBER DEFAULT 1,
        p_enable_auto_kill IN NUMBER DEFAULT 0,
        p_exclude_system_operations IN NUMBER DEFAULT 1,
        p_debug IN NUMBER DEFAULT 0,
        p_alert_count OUT NUMBER
    );
    
    -- Função para verificar se usuário é protegido
    FUNCTION IS_PROTECTED_USER(p_username IN VARCHAR2) RETURN BOOLEAN;
    
    -- Procedure para kill de session
    PROCEDURE KILL_SESSION(p_sid IN NUMBER, p_serial IN NUMBER, p_result OUT VARCHAR2);
    
END PKG_PERFORMANCE_MONITOR;
/

-- Criar package body
CREATE OR REPLACE PACKAGE BODY PKG_PERFORMANCE_MONITOR AS

    -- Lista de usuários protegidos (ERP e sistemas críticos)
    c_protected_users CONSTANT VARCHAR2(500) := 'SYS,SYSTEM,DBSNMP,ORACLE_OCM,PROTHEUS,SMARTVIEW,TOTVSTSS,APPSERVER';
    
    -- Função para verificar se usuário é protegido
    FUNCTION IS_PROTECTED_USER(p_username IN VARCHAR2) RETURN BOOLEAN IS
    BEGIN
        RETURN INSTR(UPPER(c_protected_users), UPPER(p_username)) > 0;
    END IS_PROTECTED_USER;
    
    -- Procedure para kill de session
    PROCEDURE KILL_SESSION(p_sid IN NUMBER, p_serial IN NUMBER, p_result OUT VARCHAR2) IS
        v_sql VARCHAR2(100);
    BEGIN
        v_sql := 'ALTER SYSTEM KILL SESSION ''' || p_sid || ',' || p_serial || ''' IMMEDIATE';
        EXECUTE IMMEDIATE v_sql;
        p_result := 'SUCCESS';
    EXCEPTION
        WHEN OTHERS THEN
            p_result := 'ERROR: ' || SQLERRM;
    END KILL_SESSION;

    -- Procedure principal de monitoramento
    PROCEDURE SP_MONITOR_PERFORMANCE_DB(
        p_transaction_threshold_minutes IN NUMBER DEFAULT 10,
        p_query_threshold_minutes IN NUMBER DEFAULT 10,
        p_auto_kill_threshold_minutes IN NUMBER DEFAULT 60,
        p_enable_transaction_alerts IN NUMBER DEFAULT 1,
        p_enable_blocking_alerts IN NUMBER DEFAULT 1,
        p_enable_long_query_alerts IN NUMBER DEFAULT 1,
        p_enable_auto_kill IN NUMBER DEFAULT 0,
        p_exclude_system_operations IN NUMBER DEFAULT 1,
        p_debug IN NUMBER DEFAULT 0,
        p_alert_count OUT NUMBER
    ) IS
        
        v_server_name VARCHAR2(128) := SYS_CONTEXT('USERENV', 'SERVER_HOST');
        v_current_time TIMESTAMP := SYSTIMESTAMP;
        v_alert_count NUMBER := 0;
        
        -- Cursores para diferentes tipos de monitoramento
        CURSOR c_long_transactions IS
            SELECT DISTINCT
                s.sid,
                s.serial#,
                s.username,
                s.machine,
                s.program,
                s.osuser,
                ROUND((SYSDATE - t.start_date) * 24 * 60, 2) as duration_minutes,
                CASE 
                    WHEN UPPER(s.program) LIKE '%PROTHEUS%' THEN 'Protheus ERP'
                    WHEN UPPER(s.program) LIKE '%DBACCESS%' THEN 'DBAccess'
                    WHEN UPPER(s.program) LIKE '%SMARTCLIENT%' THEN 'SmartClient'
                    WHEN UPPER(s.program) LIKE '%APPSERVER%' THEN 'AppServer'
                    ELSE 'Other Application'
                END as application_type,
                SUBSTR(REPLACE(REPLACE(REPLACE(sql.sql_text, CHR(10), ' '), CHR(13), ' '), CHR(9), ' '), 1, 400) as sql_snippet
            FROM v$session s
            JOIN v$transaction t ON s.saddr = t.ses_addr
            LEFT JOIN v$sql sql ON s.sql_id = sql.sql_id
            WHERE s.type = 'USER'
                AND s.username IS NOT NULL
                AND (SYSDATE - t.start_date) * 24 * 60 > p_transaction_threshold_minutes
                AND (p_exclude_system_operations = 0 OR s.username NOT IN ('SYS', 'SYSTEM', 'DBSNMP', 'ORACLE_OCM'))
            ORDER BY duration_minutes DESC;
            
        CURSOR c_blocking_sessions IS
            SELECT 
                s.sid,
                s.serial#,
                s.username,
                s.machine,
                s.program,
                s.osuser,
                s.blocking_session,
                s.event,
                ROUND(s.wait_time / 100, 2) as wait_seconds,
                bs.username as blocking_username,
                bs.machine as blocking_machine,
                SUBSTR(REPLACE(REPLACE(REPLACE(sql.sql_text, CHR(10), ' '), CHR(13), ' '), CHR(9), ' '), 1, 400) as sql_snippet
            FROM v$session s
            LEFT JOIN v$session bs ON s.blocking_session = bs.sid
            LEFT JOIN v$sql sql ON s.sql_id = sql.sql_id
            WHERE s.blocking_session IS NOT NULL
                AND s.blocking_session > 0
                AND s.type = 'USER'
                AND s.username IS NOT NULL
            ORDER BY s.wait_time DESC;
            
        CURSOR c_long_queries IS
            SELECT 
                s.sid,
                s.serial#,
                s.username,
                s.machine,
                s.program,
                s.osuser,
                s.command,
                s.status,
                ROUND(s.last_call_et / 60, 2) as elapsed_minutes,
                ROUND(ss.value / 100, 2) as cpu_seconds,
                st.block_gets,
                st.consistent_gets,
                st.physical_reads,
                SUBSTR(REPLACE(REPLACE(REPLACE(sql.sql_text, CHR(10), ' '), CHR(13), ' '), CHR(9), ' '), 1, 400) as sql_snippet,
                CASE 
                    WHEN UPPER(s.program) LIKE '%PROTHEUS%' THEN 'Protheus ERP'
                    WHEN UPPER(s.program) LIKE '%DBACCESS%' THEN 'DBAccess'
                    WHEN UPPER(s.program) LIKE '%SMARTCLIENT%' THEN 'SmartClient'
                    WHEN UPPER(s.program) LIKE '%APPSERVER%' THEN 'AppServer'
                    ELSE 'Other Application'
                END as application_type
            FROM v$session s
            LEFT JOIN v$sql sql ON s.sql_id = sql.sql_id
            LEFT JOIN v$sesstat ss ON s.sid = ss.sid AND ss.statistic# = (SELECT statistic# FROM v$statname WHERE name = 'CPU used by this session')
            LEFT JOIN v$sess_io st ON s.sid = st.sid
            WHERE s.type = 'USER'
                AND s.username IS NOT NULL
                AND s.status = 'ACTIVE'
                AND s.last_call_et > (p_query_threshold_minutes * 60)
                AND (p_exclude_system_operations = 0 OR s.username NOT IN ('SYS', 'SYSTEM', 'DBSNMP', 'ORACLE_OCM'))
            ORDER BY s.last_call_et DESC;
        
        -- Variáveis para processamento
        v_should_kill BOOLEAN := FALSE;
        v_action_taken VARCHAR2(100) := 'ALERTED';
        v_is_protected_user BOOLEAN := FALSE;
        v_error_msg VARCHAR2(500) := NULL;
        v_kill_result VARCHAR2(500);
        
    BEGIN
        IF p_debug = 1 THEN
            DBMS_OUTPUT.PUT_LINE('Iniciando monitoramento: ' || v_server_name || ' em ' || TO_CHAR(v_current_time, 'DD/MM/YYYY HH24:MI:SS'));
        END IF;
        
        -- =====================================================
        -- 1. VERIFICAR TRANSAÇÕES LONGAS
        -- =====================================================
        IF p_enable_transaction_alerts = 1 THEN
            IF p_debug = 1 THEN
                DBMS_OUTPUT.PUT_LINE('Verificando transações longas...');
            END IF;
            
            FOR rec IN c_long_transactions LOOP
                v_should_kill := FALSE;
                v_action_taken := 'ALERTED';
                v_is_protected_user := IS_PROTECTED_USER(rec.username);
                v_error_msg := NULL;
                
                -- Verificar se é usuário protegido
                IF v_is_protected_user THEN
                    v_action_taken := 'PROTECTED_USER';
                END IF;
                
                -- Auto-kill se habilitado e não for usuário protegido
                IF p_enable_auto_kill = 1 AND rec.duration_minutes >= p_auto_kill_threshold_minutes AND NOT v_is_protected_user THEN
                    KILL_SESSION(rec.sid, rec.serial#, v_kill_result);
                    
                    IF INSTR(v_kill_result, 'SUCCESS') > 0 THEN
                        v_should_kill := TRUE;
                        v_action_taken := 'AUTO_KILLED';
                        IF p_debug = 1 THEN
                            DBMS_OUTPUT.PUT_LINE('Auto-kill executado na sessão: ' || rec.sid);
                        END IF;
                    ELSE
                        v_error_msg := v_kill_result;
                        v_action_taken := 'KILL_FAILED';
                        IF p_debug = 1 THEN
                            DBMS_OUTPUT.PUT_LINE('Erro no auto-kill sessão ' || rec.sid || ': ' || v_error_msg);
                        END IF;
                    END IF;
                END IF;
                
                -- Registrar no log
                INSERT INTO PERFORMANCE_MONITOR_LOG (
                    EVENT_TYPE, SESSION_ID, DURATION_MINUTES, USERNAME, HOSTNAME, 
                    PROGRAM_NAME, APPLICATION_TYPE, SQL_TEXT, ACTION_TAKEN, ERROR_MESSAGE,
                    MACHINE, OSUSER
                ) VALUES (
                    'LONG_TRANSACTION', rec.sid, rec.duration_minutes, rec.username, rec.machine,
                    rec.program, rec.application_type, rec.sql_snippet, v_action_taken, v_error_msg,
                    rec.machine, rec.osuser
                );
                
                v_alert_count := v_alert_count + 1;
            END LOOP;
        END IF;
        
        -- =====================================================
        -- 2. VERIFICAR BLOQUEIOS ATIVOS
        -- =====================================================
        IF p_enable_blocking_alerts = 1 THEN
            IF p_debug = 1 THEN
                DBMS_OUTPUT.PUT_LINE('Verificando bloqueios ativos...');
            END IF;
            
            FOR rec IN c_blocking_sessions LOOP
                -- Registrar bloqueio no log
                INSERT INTO PERFORMANCE_MONITOR_LOG (
                    EVENT_TYPE, SESSION_ID, WAIT_SECONDS, USERNAME, HOSTNAME, PROGRAM_NAME,
                    SQL_TEXT, ACTION_TAKEN, BLOCKING_SESSION_ID, WAIT_EVENT, MACHINE, OSUSER
                ) VALUES (
                    'BLOCKING', rec.sid, rec.wait_seconds, rec.username, rec.machine, rec.program,
                    rec.sql_snippet, 'BLOCKING_DETECTED', rec.blocking_session, rec.event, rec.machine, rec.osuser
                );
                
                v_alert_count := v_alert_count + 1;
                
                IF p_debug = 1 THEN
                    DBMS_OUTPUT.PUT_LINE('Bloqueio detectado - Sessão: ' || rec.sid || ' bloqueada por: ' || rec.blocking_session);
                END IF;
            END LOOP;
        END IF;
        
        -- =====================================================
        -- 3. VERIFICAR QUERIES LONGAS
        -- =====================================================
        IF p_enable_long_query_alerts = 1 THEN
            IF p_debug = 1 THEN
                DBMS_OUTPUT.PUT_LINE('Verificando queries longas...');
            END IF;
            
            FOR rec IN c_long_queries LOOP
                v_should_kill := FALSE;
                v_action_taken := 'ALERTED';
                v_is_protected_user := IS_PROTECTED_USER(rec.username);
                v_error_msg := NULL;
                
                -- Verificar se é usuário protegido
                IF v_is_protected_user THEN
                    v_action_taken := 'PROTECTED_USER';
                END IF;
                
                -- Auto-kill se habilitado e não for usuário protegido
                IF p_enable_auto_kill = 1 AND rec.elapsed_minutes >= p_auto_kill_threshold_minutes AND NOT v_is_protected_user THEN
                    KILL_SESSION(rec.sid, rec.serial#, v_kill_result);
                    
                    IF INSTR(v_kill_result, 'SUCCESS') > 0 THEN
                        v_should_kill := TRUE;
                        v_action_taken := 'AUTO_KILLED';
                        IF p_debug = 1 THEN
                            DBMS_OUTPUT.PUT_LINE('Auto-kill query executado na sessão: ' || rec.sid);
                        END IF;
                    ELSE
                        v_error_msg := v_kill_result;
                        v_action_taken := 'KILL_FAILED';
                        IF p_debug = 1 THEN
                            DBMS_OUTPUT.PUT_LINE('Erro no auto-kill query sessão ' || rec.sid || ': ' || v_error_msg);
                        END IF;
                    END IF;
                END IF;
                
                -- Registrar no log
                INSERT INTO PERFORMANCE_MONITOR_LOG (
                    EVENT_TYPE, SESSION_ID, DURATION_MINUTES, USERNAME, HOSTNAME, PROGRAM_NAME, 
                    APPLICATION_TYPE, COMMAND, STATUS, CPU_SECONDS, BLOCK_GETS, CONSISTENT_GETS,
                    PHYSICAL_READS, SQL_TEXT, ACTION_TAKEN, ERROR_MESSAGE, MACHINE, OSUSER
                ) VALUES (
                    'LONG_QUERY', rec.sid, rec.elapsed_minutes, rec.username, rec.machine, rec.program,
                    rec.application_type, rec.command, rec.status, rec.cpu_seconds, rec.block_gets, rec.consistent_gets,
                    rec.physical_reads, rec.sql_snippet, v_action_taken, v_error_msg, rec.machine, rec.osuser
                );
                
                v_alert_count := v_alert_count + 1;
            END LOOP;
        END IF;
        
        -- =====================================================
        -- RESUMO FINAL
        -- =====================================================
        DECLARE
            v_success_count NUMBER;
            v_error_count NUMBER;
            v_killed_count NUMBER;
            v_protected_count NUMBER;
        BEGIN
            SELECT COUNT(*) INTO v_success_count 
            FROM PERFORMANCE_MONITOR_LOG 
            WHERE EVENT_TIME >= v_current_time - INTERVAL '1' MINUTE AND ACTION_TAKEN = 'ALERTED';
            
            SELECT COUNT(*) INTO v_killed_count 
            FROM PERFORMANCE_MONITOR_LOG 
            WHERE EVENT_TIME >= v_current_time - INTERVAL '1' MINUTE AND ACTION_TAKEN = 'AUTO_KILLED';
            
            SELECT COUNT(*) INTO v_protected_count 
            FROM PERFORMANCE_MONITOR_LOG 
            WHERE EVENT_TIME >= v_current_time - INTERVAL '1' MINUTE AND ACTION_TAKEN = 'PROTECTED_USER';
            
            SELECT COUNT(*) INTO v_error_count 
            FROM PERFORMANCE_MONITOR_LOG 
            WHERE EVENT_TIME >= v_current_time - INTERVAL '1' MINUTE AND ACTION_TAKEN LIKE '%FAILED%';
            
            DBMS_OUTPUT.PUT_LINE('============ RESUMO MONITORAMENTO ============');
            DBMS_OUTPUT.PUT_LINE('Total de eventos detectados: ' || v_alert_count);
            DBMS_OUTPUT.PUT_LINE('Processos finalizados automaticamente: ' || v_killed_count);
            DBMS_OUTPUT.PUT_LINE('Usuários protegidos (não finalizados): ' || v_protected_count);
            DBMS_OUTPUT.PUT_LINE('Falhas na finalização: ' || v_error_count);
            DBMS_OUTPUT.PUT_LINE('Servidor: ' || v_server_name);
            DBMS_OUTPUT.PUT_LINE('Timestamp: ' || TO_CHAR(v_current_time, 'DD/MM/YYYY HH24:MI:SS'));
            
            IF p_debug = 1 THEN
                DBMS_OUTPUT.PUT_LINE('');
                DBMS_OUTPUT.PUT_LINE('Detalhes dos eventos (últimos 10):');
                FOR rec IN (
                    SELECT EVENT_TIME, EVENT_TYPE, SESSION_ID, 
                           NVL(DURATION_MINUTES, WAIT_SECONDS) as DURATION_WAIT,
                           USERNAME, APPLICATION_TYPE, ACTION_TAKEN,
                           CASE WHEN LENGTH(SQL_TEXT) > 100 THEN SUBSTR(SQL_TEXT, 1, 100) || '...' ELSE SQL_TEXT END as SQL_PREVIEW
                    FROM PERFORMANCE_MONITOR_LOG
                    WHERE EVENT_TIME >= v_current_time - INTERVAL '1' HOUR
                    ORDER BY EVENT_TIME DESC
                    FETCH FIRST 10 ROWS ONLY
                ) LOOP
                    DBMS_OUTPUT.PUT_LINE(TO_CHAR(rec.EVENT_TIME, 'HH24:MI:SS') || ' | ' || 
                                       rec.EVENT_TYPE || ' | SID:' || rec.SESSION_ID || ' | ' || 
                                       rec.USERNAME || ' | ' || rec.ACTION_TAKEN);
                END LOOP;
            END IF;
        END;
        
        p_alert_count := v_alert_count;
        COMMIT;
        
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE('Erro durante monitoramento: ' || SQLERRM);
            p_alert_count := -1;
    END SP_MONITOR_PERFORMANCE_DB;
    
END PKG_PERFORMANCE_MONITOR;
/

-- =====================================================
-- 3. PROCEDURE WRAPPER PARA COMPATIBILIDADE
-- =====================================================
CREATE OR REPLACE PROCEDURE SP_MONITOR_PERFORMANCE_DB(
    p_transaction_threshold_minutes IN NUMBER DEFAULT 10,
    p_query_threshold_minutes IN NUMBER DEFAULT 10,
    p_auto_kill_threshold_minutes IN NUMBER DEFAULT 60,
    p_enable_transaction_alerts IN NUMBER DEFAULT 1,
    p_enable_blocking_alerts IN NUMBER DEFAULT 1,
    p_enable_long_query_alerts IN NUMBER DEFAULT 1,
    p_enable_auto_kill IN NUMBER DEFAULT 0,
    p_exclude_system_operations IN NUMBER DEFAULT 1,
    p_debug IN NUMBER DEFAULT 0
) AS
    v_alert_count NUMBER;
BEGIN
    PKG_PERFORMANCE_MONITOR.SP_MONITOR_PERFORMANCE_DB(
        p_transaction_threshold_minutes => p_transaction_threshold_minutes,
        p_query_threshold_minutes => p_query_threshold_minutes,
        p_auto_kill_threshold_minutes => p_auto_kill_threshold_minutes,
        p_enable_transaction_alerts => p_enable_transaction_alerts,
        p_enable_blocking_alerts => p_enable_blocking_alerts,
        p_enable_long_query_alerts => p_enable_long_query_alerts,
        p_enable_auto_kill => p_enable_auto_kill,
        p_exclude_system_operations => p_exclude_system_operations,
        p_debug => p_debug,
        p_alert_count => v_alert_count
    );
END;
/

-- =====================================================
-- 4. QUERIES ÚTEIS PARA ANÁLISE DOS LOGS
-- =====================================================

-- Visualizar eventos recentes (última hora)
/*
SELECT 
    EVENT_TIME,
    EVENT_TYPE,
    SESSION_ID,
    DURATION_MINUTES,
    USERNAME,
    HOSTNAME,
    APPLICATION_TYPE,
    ACTION_TAKEN,
    CASE WHEN LENGTH(SQL_TEXT) > 200 THEN SUBSTR(SQL_TEXT, 1, 200) || '...' ELSE SQL_TEXT END as SQL_PREVIEW
FROM PERFORMANCE_MONITOR_LOG
WHERE EVENT_TIME >= SYSTIMESTAMP - INTERVAL '1' HOUR
ORDER BY EVENT_TIME DESC;
-- IMPORTANTE: PERMISSÕES E TESTES ANTES DE PUBLICAR
-- =================================================
-- 
-- ATENÇÃO: Este script foi convertido do SQL Server para Oracle.
-- Antes de usar em produção, certifique-se de:
--
-- 1. PERMISSÕES NECESSÁRIAS:
--    GRANT SELECT ON v$session TO <usuario>;
--    GRANT SELECT ON v$transaction TO <usuario>;
--    GRANT SELECT ON v$sql TO <usuario>;
--    GRANT SELECT ON v$sesstat TO <usuario>;
--    GRANT SELECT ON v$sess_io TO <usuario>;
--    GRANT SELECT ON v$statname TO <usuario>;
--    GRANT ALTER SYSTEM TO <usuario>;
--    GRANT CREATE JOB TO <usuario>;
--
-- 2. TESTE EM AMBIENTE DE DESENVOLVIMENTO PRIMEIRO!
-- 3. SEMPRE EXECUTE PRIMEIRO COM p_enable_auto_kill => 0
-- 4. MONITORE OS LOGS E AJUSTE OS THRESHOLDS
-- 5. CONSIDERE O IMPACTO DO KILL SESSION EM PRODUÇÃO
--
-- LIMITAÇÕES CONHECIDAS:
-- - Detecção de bloqueios pode não capturar todos os casos
-- - Comando KILL SESSION requer privilégios administrativos
-- - Algumas consultas podem ter performance impacto em sistemas muito carregados
--

-- Estatísticas por tipo de evento (últimas 24 horas)
/*
SELECT 
    EVENT_TYPE,
    COUNT(*) as TOTAL_EVENTS,
    COUNT(CASE WHEN ACTION_TAKEN = 'AUTO_KILLED' THEN 1 END) as AUTO_KILLED,
    COUNT(CASE WHEN ACTION_TAKEN = 'PROTECTED_USER' THEN 1 END) as PROTECTED_USERS,
    ROUND(AVG(DURATION_MINUTES), 2) as AVG_DURATION_MINUTES,
    ROUND(MAX(DURATION_MINUTES), 2) as MAX_DURATION_MINUTES
FROM PERFORMANCE_MONITOR_LOG
WHERE EVENT_TIME >= SYSTIMESTAMP - INTERVAL '1' DAY
GROUP BY EVENT_TYPE
ORDER BY TOTAL_EVENTS DESC;
*/

-- Top usuários com mais problemas de performance (última semana)
/*
SELECT 
    USERNAME,
    COUNT(*) as TOTAL_ISSUES,
    COUNT(CASE WHEN EVENT_TYPE = 'LONG_QUERY' THEN 1 END) as LONG_QUERIES,
    COUNT(CASE WHEN EVENT_TYPE = 'LONG_TRANSACTION' THEN 1 END) as LONG_TRANSACTIONS,
    COUNT(CASE WHEN EVENT_TYPE = 'BLOCKING' THEN 1 END) as BLOCKINGS,
    ROUND(AVG(DURATION_MINUTES), 2) as AVG_DURATION
FROM PERFORMANCE_MONITOR_LOG
WHERE EVENT_TIME >= SYSTIMESTAMP - INTERVAL '7' DAY
    AND USERNAME IS NOT NULL
GROUP BY USERNAME
HAVING COUNT(*) > 5
ORDER BY TOTAL_ISSUES DESC;
*/

-- Sessões ativas no momento
/*
SELECT 
    s.sid,
    s.serial#,
    s.username,
    s.program,
    s.machine,
    s.status,
    s.logon_time,
    ROUND((SYSDATE - s.logon_time) * 24 * 60, 2) as session_minutes,
    ROUND(s.last_call_et / 60, 2) as idle_minutes,
    SUBSTR(sql.sql_text, 1, 100) as current_sql
FROM v$session s
LEFT JOIN v$sql sql ON s.sql_id = sql.sql_id
WHERE s.type = 'USER'
    AND s.username IS NOT NULL
ORDER BY session_minutes DESC;
*/

-- =====================================================
-- 5. JOB PARA AGENDAMENTO AUTOMÁTICO
-- =====================================================
/*
-- Criar job para executar a cada 5 minutos
BEGIN
    DBMS_SCHEDULER.CREATE_JOB(
        job_name => 'PERFORMANCE_MONITOR_JOB',
        job_type => 'PLSQL_BLOCK',
        job_action => 'BEGIN SP_MONITOR_PERFORMANCE_DB(p_enable_auto_kill => 1, p_auto_kill_threshold_minutes => 30, p_debug => 0); END;',
        start_date => SYSTIMESTAMP,
        repeat_interval => 'FREQ=MINUTELY; INTERVAL=5',
        enabled => TRUE,
        comments => 'Monitoramento automatico de performance'
    );
END;
/

-- Para parar o job
BEGIN
    DBMS_SCHEDULER.DROP_JOB('PERFORMANCE_MONITOR_JOB');
END;
/

-- Verificar status do job
SELECT job_name, enabled, state, last_start_date, next_run_date 
FROM user_scheduler_jobs 
WHERE job_name = 'PERFORMANCE_MONITOR_JOB';
*/

-- =====================================================
-- 6. INSTRUÇÕES DE USO
-- =====================================================
/*
CONFIGURAÇÃO INICIAL:
1. Execute a seção de criação da tabela (seção 1) apenas uma vez
2. Execute a criação do package (seção 2) 
3. A procedure wrapper (seção 3) permite chamadas simples

EXECUÇÃO MANUAL:
-- Modo de teste (só registra, não mata processos)
EXEC SP_MONITOR_PERFORMANCE_DB(p_debug => 1);

-- Modo conservador (mata processos > 60 minutos)
EXEC SP_MONITOR_PERFORMANCE_DB(p_enable_auto_kill => 1, p_auto_kill_threshold_minutes => 60, p_debug => 1);

-- Modo agressivo (mata processos > 15 minutos)
EXEC SP_MONITOR_PERFORMANCE_DB(p_enable_auto_kill => 1, p_auto_kill_threshold_minutes => 15);

AGENDAMENTO VIA DBMS_SCHEDULER:
Use o exemplo da seção 5 para criar um job automático

PARÂMETROS PRINCIPAIS:
- p_transaction_threshold_minutes: Threshold para alertar sobre transações longas (padrão: 10)
- p_query_threshold_minutes: Threshold para alertar sobre queries longas (padrão: 10)
- p_auto_kill_threshold_minutes: Threshold para auto-kill de processos (padrão: 60)
- p_enable_auto_kill: Habilita finalização automática de processos (padrão: 0 - DESABILITADO)
- p_enable_transaction_alerts: Habilita monitoramento de transações longas (padrão: 1)
- p_enable_blocking_alerts: Habilita monitoramento de bloqueios (padrão: 1)
- p_enable_long_query_alerts: Habilita monitoramento de queries longas (padrão: 1)
- p_debug: Exibe informações detalhadas durante execução (padrão: 0)

USUÁRIOS PROTEGIDOS (NUNCA SÃO FINALIZADOS):
- SYS, SYSTEM, DBSNMP, ORACLE_OCM, PROTHEUS, SMARTVIEW, TOTVSTSS, APPSERVER

ANÁLISE DOS LOGS:
Use as queries comentadas na seção 4 para analisar:
- Eventos recentes
- Estatísticas por tipo
- Usuários com mais problemas
- Sessões ativas no momento

MANUTENÇÃO:
-- Limpeza de logs antigos (manter apenas últimos 30 dias)
DELETE FROM PERFORMANCE_MONITOR_LOG 
WHERE EVENT_TIME < SYSTIMESTAMP - INTERVAL '30' DAY;

IMPORTANTE:
- Sempre teste primeiro com p_enable_auto_kill => 0
- Monitore os logs regularmente
- Ajuste os thresholds conforme necessário
- Faça backup antes de implementar em produção
- Teste as permissões necessárias para ALTER SYSTEM KILL SESSION

DIFERENÇAS DO SQL SERVER PARA ORACLE:
- Usa v$session, v$transaction, v$session_wait ao invés de sys.dm_exec_sessions
- ALTER SYSTEM KILL SESSION ao invés de KILL
- SYSTIMESTAMP ao invés de GETDATE()
- CLOB ao invés de NVARCHAR(MAX)
- NUMBER ao invés de INT/BIGINT
- Packages ao invés de stored procedures simples
- DBMS_SCHEDULER ao invés de SQL Agent Jobs
- SID,SERIAL# ao invés de apenas session_id
- v$sql ao invés de sys.dm_exec_sql_text
- v$sesstat/v$sess_io para estatísticas de CPU e I/O

PERMISSÕES NECESSÁRIAS:
O usuário que executar este script precisa das seguintes permissões:
- CREATE TABLE, CREATE PROCEDURE, CREATE PACKAGE
- SELECT on v$session, v$transaction, v$session_wait, v$sql, v$sesstat, v$sess_io, v$statname
- ALTER SYSTEM (para kill sessions)
- CREATE JOB (para agendamento automático)

Grant exemplo:
GRANT SELECT ON v$session TO <usuario>;
GRANT SELECT ON v$transaction TO <usuario>;
GRANT SELECT ON v$session_wait TO <usuario>;
GRANT SELECT ON v$sql TO <usuario>;
GRANT SELECT ON v$sesstat TO <usuario>;
GRANT SELECT ON v$sess_io TO <usuario>;
GRANT SELECT ON v$statname TO <usuario>;
GRANT ALTER SYSTEM TO <usuario>;
GRANT CREATE JOB TO <usuario>;
*/

-- =====================================================
-- 7. VIEWS AUXILIARES PARA MONITORAMENTO
-- =====================================================

-- View para sessões ativas com informações detalhadas
CREATE OR REPLACE VIEW V_ACTIVE_SESSIONS AS
SELECT 
    s.sid,
    s.serial#,
    s.username,
    s.program,
    s.machine,
    s.osuser,
    s.status,
    s.logon_time,
    ROUND((SYSDATE - s.logon_time) * 24 * 60, 2) as session_duration_minutes,
    ROUND(s.last_call_et / 60, 2) as idle_minutes,
    s.sql_id,
    s.prev_sql_id,
    SUBSTR(sql.sql_text, 1, 200) as current_sql,
    CASE 
        WHEN UPPER(s.program) LIKE '%PROTHEUS%' THEN 'Protheus ERP'
        WHEN UPPER(s.program) LIKE '%DBACCESS%' THEN 'DBAccess'
        WHEN UPPER(s.program) LIKE '%SMARTCLIENT%' THEN 'SmartClient'
        WHEN UPPER(s.program) LIKE '%APPSERVER%' THEN 'AppServer'
        WHEN UPPER(s.program) LIKE '%SQLPLUS%' THEN 'SQL*Plus'
        WHEN UPPER(s.program) LIKE '%TOAD%' THEN 'Toad'
        WHEN UPPER(s.program) LIKE '%PLSQL%' THEN 'PL/SQL Developer'
        ELSE 'Other Application'
    END as application_type,
    -- Informações de transação se existir
    CASE WHEN t.start_date IS NOT NULL THEN 
        ROUND((SYSDATE - t.start_date) * 24 * 60, 2) 
    END as transaction_duration_minutes,
    -- Informações de wait se existir
    s.event as wait_event,
    CASE WHEN s.wait_time > 0 THEN 
        ROUND(s.wait_time / 100, 2) 
    END as wait_seconds,
    s.blocking_session
FROM v$session s
LEFT JOIN v$sql sql ON s.sql_id = sql.sql_id
LEFT JOIN v$transaction t ON s.saddr = t.ses_addr
WHERE s.type = 'USER'
    AND s.username IS NOT NULL;

-- View para bloqueios ativos
CREATE OR REPLACE VIEW V_BLOCKING_SESSIONS AS
SELECT 
    s.sid as blocked_sid,
    s.serial# as blocked_serial,
    bs.sid as blocking_sid,
    bs.serial# as blocking_serial,
    s.username as blocked_user,
    bs.username as blocking_user,
    s.program as blocked_program,
    bs.program as blocking_program,
    s.machine as blocked_machine,
    bs.machine as blocking_machine,
    s.event,
    ROUND(s.wait_time / 100, 2) as wait_seconds,
    blocked_sql.sql_text as blocked_sql,
    blocking_sql.sql_text as blocking_sql,
    -- Tempo da transação do bloqueador
    CASE WHEN bt.start_date IS NOT NULL THEN 
        ROUND((SYSDATE - bt.start_date) * 24 * 60, 2) 
    END as blocking_transaction_minutes
FROM v$session s
JOIN v$session bs ON s.blocking_session = bs.sid
LEFT JOIN v$sql blocked_sql ON s.sql_id = blocked_sql.sql_id
LEFT JOIN v$sql blocking_sql ON bs.sql_id = blocking_sql.sql_id
LEFT JOIN v$transaction bt ON bs.saddr = bt.ses_addr
WHERE s.blocking_session IS NOT NULL
    AND s.blocking_session > 0
    AND s.type = 'USER';

-- View para estatísticas de performance por usuário
CREATE OR REPLACE VIEW V_USER_PERFORMANCE_STATS AS
SELECT 
    USERNAME,
    COUNT(*) as TOTAL_EVENTS,
    COUNT(CASE WHEN EVENT_TYPE = 'LONG_QUERY' THEN 1 END) as LONG_QUERIES,
    COUNT(CASE WHEN EVENT_TYPE = 'LONG_TRANSACTION' THEN 1 END) as LONG_TRANSACTIONS,
    COUNT(CASE WHEN EVENT_TYPE = 'BLOCKING' THEN 1 END) as BLOCKINGS,
    COUNT(CASE WHEN ACTION_TAKEN = 'AUTO_KILLED' THEN 1 END) as AUTO_KILLED,
    COUNT(CASE WHEN ACTION_TAKEN = 'PROTECTED_USER' THEN 1 END) as PROTECTED_EVENTS,
    ROUND(AVG(DURATION_MINUTES), 2) as AVG_DURATION_MINUTES,
    ROUND(MAX(DURATION_MINUTES), 2) as MAX_DURATION_MINUTES,
    MIN(EVENT_TIME) as FIRST_EVENT,
    MAX(EVENT_TIME) as LAST_EVENT
FROM PERFORMANCE_MONITOR_LOG
WHERE EVENT_TIME >= SYSTIMESTAMP - INTERVAL '7' DAY
    AND USERNAME IS NOT NULL
GROUP BY USERNAME
ORDER BY TOTAL_EVENTS DESC;

-- =====================================================
-- 8. ALERTAS E NOTIFICAÇÕES
-- =====================================================

-- Procedure para enviar alertas (pode ser customizada)
CREATE OR REPLACE PROCEDURE SP_SEND_PERFORMANCE_ALERT(
    p_alert_type IN VARCHAR2,
    p_session_id IN NUMBER,
    p_username IN VARCHAR2,
    p_duration IN NUMBER,
    p_action_taken IN VARCHAR2
) AS
    v_message VARCHAR2(4000);
    v_subject VARCHAR2(200);
BEGIN
    v_subject := 'Alerta Performance Oracle - ' || p_alert_type;
    
    v_message := 'ALERTA DE PERFORMANCE DETECTADO' || CHR(10) ||
                 '================================' || CHR(10) ||
                 'Tipo: ' || p_alert_type || CHR(10) ||
                 'SID: ' || p_session_id || CHR(10) ||
                 'Usuário: ' || p_username || CHR(10) ||
                 'Duração: ' || p_duration || ' minutos' || CHR(10) ||
                 'Ação Tomada: ' || p_action_taken || CHR(10) ||
                 'Servidor: ' || SYS_CONTEXT('USERENV', 'SERVER_HOST') || CHR(10) ||
                 'Data/Hora: ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS');
    
    -- Aqui você pode integrar com:
    -- 1. UTL_MAIL para envio de emails
    -- 2. UTL_HTTP para webhooks
    -- 3. DBMS_ALERT para alertas internos
    -- 4. Logs de aplicação
    
    -- Exemplo básico com log no alert.log
    DBMS_SYSTEM.KSDWRT(2, v_subject || ': ' || v_message);
    
    -- Exemplo para inserir em tabela de alertas
    /*
    INSERT INTO PERFORMANCE_ALERTS (
        ALERT_TIME, ALERT_TYPE, SESSION_ID, USERNAME, 
        DURATION_MINUTES, ACTION_TAKEN, MESSAGE
    ) VALUES (
        SYSDATE, p_alert_type, p_session_id, p_username,
        p_duration, p_action_taken, v_message
    );
    */
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log do erro sem interromper o processo principal
        DBMS_SYSTEM.KSDWRT(2, 'Erro ao enviar alerta: ' || SQLERRM);
END;
/

-- =====================================================
-- 9. RELATÓRIOS E DASHBOARDS
-- =====================================================

-- Relatório diário de performance
CREATE OR REPLACE PROCEDURE SP_DAILY_PERFORMANCE_REPORT AS
    v_report CLOB;
    v_total_events NUMBER;
    v_auto_killed NUMBER;
    v_protected NUMBER;
    v_avg_duration NUMBER;
BEGIN
    -- Cabeçalho do relatório
    v_report := 'RELATÓRIO DIÁRIO DE PERFORMANCE - ' || TO_CHAR(SYSDATE, 'DD/MM/YYYY') || CHR(10) ||
                '================================================' || CHR(10) || CHR(10);
    
    -- Resumo geral
    SELECT COUNT(*), 
           COUNT(CASE WHEN ACTION_TAKEN = 'AUTO_KILLED' THEN 1 END),
           COUNT(CASE WHEN ACTION_TAKEN = 'PROTECTED_USER' THEN 1 END),
           ROUND(AVG(DURATION_MINUTES), 2)
    INTO v_total_events, v_auto_killed, v_protected, v_avg_duration
    FROM PERFORMANCE_MONITOR_LOG
    WHERE EVENT_TIME >= TRUNC(SYSDATE);
    
    v_report := v_report || 'RESUMO GERAL:' || CHR(10) ||
                'Total de eventos: ' || v_total_events || CHR(10) ||
                'Processos finalizados: ' || v_auto_killed || CHR(10) ||
                'Usuários protegidos: ' || v_protected || CHR(10) ||
                'Duração média: ' || v_avg_duration || ' minutos' || CHR(10) || CHR(10);
    
    -- Eventos por tipo
    v_report := v_report || 'EVENTOS POR TIPO:' || CHR(10);
    FOR rec IN (
        SELECT EVENT_TYPE, COUNT(*) as QTD
        FROM PERFORMANCE_MONITOR_LOG
        WHERE EVENT_TIME >= TRUNC(SYSDATE)
        GROUP BY EVENT_TYPE
        ORDER BY QTD DESC
    ) LOOP
        v_report := v_report || rec.EVENT_TYPE || ': ' || rec.QTD || CHR(10);
    END LOOP;
    
    v_report := v_report || CHR(10);
    
    -- Top usuários
    v_report := v_report || 'TOP 10 USUÁRIOS COM PROBLEMAS:' || CHR(10);
    FOR rec IN (
        SELECT USERNAME, COUNT(*) as QTD, ROUND(AVG(DURATION_MINUTES), 2) as AVG_DURATION
        FROM PERFORMANCE_MONITOR_LOG
        WHERE EVENT_TIME >= TRUNC(SYSDATE)
            AND USERNAME IS NOT NULL
        GROUP BY USERNAME
        ORDER BY QTD DESC
        FETCH FIRST 10 ROWS ONLY
    ) LOOP
        v_report := v_report || rec.USERNAME || ': ' || rec.QTD || ' eventos (avg: ' || rec.AVG_DURATION || ' min)' || CHR(10);
    END LOOP;
    
    -- Salvar relatório (você pode enviar por email, salvar em arquivo, etc.)
    DBMS_OUTPUT.PUT_LINE(v_report);
    
END;
/

-- =====================================================
-- 10. SCRIPTS DE MANUTENÇÃO
-- =====================================================

-- Procedure para limpeza automática de logs antigos
CREATE OR REPLACE PROCEDURE SP_CLEANUP_OLD_LOGS(
    p_days_to_keep IN NUMBER DEFAULT 30
) AS
    v_deleted_count NUMBER;
BEGIN
    DELETE FROM PERFORMANCE_MONITOR_LOG 
    WHERE EVENT_TIME < SYSTIMESTAMP - INTERVAL p_days_to_keep DAY;
    
    v_deleted_count := SQL%ROWCOUNT;
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Limpeza concluída. ' || v_deleted_count || ' registros removidos.');
    
    -- Recolher estatísticas da tabela após limpeza
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => USER,
        tabname => 'PERFORMANCE_MONITOR_LOG',
        cascade => TRUE
    );
    
END;
/

-- Procedure para verificar saúde do sistema de monitoramento
CREATE OR REPLACE PROCEDURE SP_CHECK_MONITOR_HEALTH AS
    v_last_run TIMESTAMP;
    v_minutes_since_last NUMBER;
    v_error_rate NUMBER;
    v_table_size NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('VERIFICAÇÃO DE SAÚDE DO SISTEMA DE MONITORAMENTO');
    DBMS_OUTPUT.PUT_LINE('=============================================');
    
    -- Verificar última execução
    SELECT MAX(EVENT_TIME) INTO v_last_run
    FROM PERFORMANCE_MONITOR_LOG;
    
    IF v_last_run IS NOT NULL THEN
        v_minutes_since_last := EXTRACT(DAY FROM (SYSTIMESTAMP - v_last_run)) * 24 * 60 +
                               EXTRACT(HOUR FROM (SYSTIMESTAMP - v_last_run)) * 60 +
                               EXTRACT(MINUTE FROM (SYSTIMESTAMP - v_last_run));
        
        DBMS_OUTPUT.PUT_LINE('Última execução: ' || TO_CHAR(v_last_run, 'DD/MM/YYYY HH24:MI:SS'));
        DBMS_OUTPUT.PUT_LINE('Minutos desde última execução: ' || ROUND(v_minutes_since_last, 2));
        
        IF v_minutes_since_last > 60 THEN
            DBMS_OUTPUT.PUT_LINE('⚠️  ATENÇÃO: Sistema não executa há mais de 1 hora!');
        END IF;
    ELSE
        DBMS_OUTPUT.PUT_LINE('❌ ERRO: Nenhuma execução encontrada!');
    END IF;
    
    -- Verificar taxa de erro
    SELECT ROUND(
        (COUNT(CASE WHEN ACTION_TAKEN LIKE '%FAILED%' THEN 1 END) * 100.0 / COUNT(*)), 2
    ) INTO v_error_rate
    FROM PERFORMANCE_MONITOR_LOG
    WHERE EVENT_TIME >= SYSTIMESTAMP - INTERVAL '1' DAY;
    
    DBMS_OUTPUT.PUT_LINE('Taxa de erro (24h): ' || v_error_rate || '%');
    
    IF v_error_rate > 10 THEN
        DBMS_OUTPUT.PUT_LINE('⚠️  ATENÇÃO: Taxa de erro elevada!');
    END IF;
    
    -- Verificar tamanho da tabela
    SELECT COUNT(*) INTO v_table_size
    FROM PERFORMANCE_MONITOR_LOG;
    
    DBMS_OUTPUT.PUT_LINE('Total de registros na tabela: ' || v_table_size);
    
    IF v_table_size > 1000000 THEN
        DBMS_OUTPUT.PUT_LINE('⚠️  ATENÇÃO: Tabela muito grande, considere limpeza!');
    END IF;
    
    -- Verificar jobs agendados
    FOR rec IN (
        SELECT job_name, enabled, state, last_start_date, next_run_date
        FROM user_scheduler_jobs 
        WHERE job_name LIKE '%PERFORMANCE%MONITOR%'
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Job: ' || rec.job_name || 
                           ' | Habilitado: ' || CASE WHEN rec.enabled = 'TRUE' THEN 'Sim' ELSE 'Não' END ||
                           ' | Status: ' || rec.state);
        DBMS_OUTPUT.PUT_LINE('Última execução: ' || TO_CHAR(rec.last_start_date, 'DD/MM/YYYY HH24:MI:SS'));
        DBMS_OUTPUT.PUT_LINE('Próxima execução: ' || TO_CHAR(rec.next_run_date, 'DD/MM/YYYY HH24:MI:SS'));
    END LOOP;
    
END;
/

-- =====================================================
-- 11. EXEMPLOS DE USO AVANÇADO
-- =====================================================

-- Exemplo de integração com email (requer configuração do UTL_MAIL)
/*
CREATE OR REPLACE PROCEDURE SP_EMAIL_ALERT(
    p_to_email IN VARCHAR2,
    p_subject IN VARCHAR2,
    p_message IN VARCHAR2
) AS
BEGIN
    UTL_MAIL.SEND(
        sender => 'oracle-monitor@empresa.com',
        recipients => p_to_email,
        subject => p_subject,
        message => p_message
    );
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Erro ao enviar email: ' || SQLERRM);
END;
/
*/

-- Exemplo de webhook para integração com Slack/Teams
/*
CREATE OR REPLACE PROCEDURE SP_WEBHOOK_ALERT(
    p_webhook_url IN VARCHAR2,
    p_message IN VARCHAR2
) AS
    req UTL_HTTP.REQ;
    resp UTL_HTTP.RESP;
    v_json VARCHAR2(4000);
BEGIN
    v_json := '{"text": "' || REPLACE(p_message, '"', '\"') || '"}';
    
    req := UTL_HTTP.BEGIN_REQUEST(p_webhook_url, 'POST');
    UTL_HTTP.SET_HEADER(req, 'Content-Type', 'application/json');
    UTL_HTTP.SET_HEADER(req, 'Content-Length', LENGTH(v_json));
    UTL_HTTP.WRITE_TEXT(req, v_json);
    
    resp := UTL_HTTP.GET_RESPONSE(req);
    UTL_HTTP.END_RESPONSE(resp);
    
EXCEPTION
    WHEN OTHERS THEN
        UTL_HTTP.END_REQUEST(req);
        DBMS_OUTPUT.PUT_LINE('Erro ao enviar webhook: ' || SQLERRM);
END;
/
*/
