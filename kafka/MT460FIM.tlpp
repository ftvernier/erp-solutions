#Include "Protheus.ch"
#Include "RestFul.ch"

/*/{Protheus.doc} M460FIM
Ponto de Entrada executado após o faturamento da nota fiscal
Envia os dados da NF para o Apache Kafka via REST API

@type User Function
@author Fernando Vernier
@since 18/10/2025
@version 2.0 - FINAL
/*/
User Function M460FIM()
    Local aArea := GetArea()
    Local cNumNF := SF2->F2_DOC
    Local cSerie := SF2->F2_SERIE
    Local cCliente := SF2->F2_CLIENTE
    Local cLoja := SF2->F2_LOJA
    
    // Chama função para enviar ao Kafka
    U_SENDKAFKA(cNumNF, cSerie, cCliente, cLoja)
    
    RestArea(aArea)
Return

/*/{Protheus.doc} U_SENDKAFKA
Função que prepara e envia os dados da NF para o Kafka

@type User Function
@author Fernando Vernier
@since 18/10/2025

@param cNumNF, Character, Número da Nota Fiscal
@param cSerie, Character, Série da Nota Fiscal
@param cCliente, Character, Código do Cliente
@param cLoja, Character, Loja do Cliente

@return Logical, .T. se enviou com sucesso
/*/
User Function SENDKAFKA(cNumNF, cSerie, cCliente, cLoja)
    Local lRet := .T.
    Local oKafka := KafkaProducer():New()
    Local oNFData := JsonObject():New()
    Local oCabec := JsonObject():New()
    Local oMeta := JsonObject():New()
    Local aItens := {}
    Local oItem
    Local cJson := ""
    
    // Dados do Cabeçalho (SF2)
    oCabec['documento'] := AllTrim(SF2->F2_DOC)
    oCabec['serie'] := AllTrim(SF2->F2_SERIE)
    oCabec['cliente'] := AllTrim(SF2->F2_CLIENTE)
    oCabec['loja'] := AllTrim(SF2->F2_LOJA)
    oCabec['nomeCliente'] := AllTrim(Posicione("SA1", 1, xFilial("SA1") + cCliente + cLoja, "A1_NOME"))
    oCabec['emissao'] := DtoC(SF2->F2_EMISSAO)
    oCabec['valorTotal'] := SF2->F2_VALBRUT
    oCabec['chaveNFe'] := AllTrim(SF2->F2_CHVNFE)
    
    // Dados dos Itens (SD2)
    SD2->(DbSetOrder(3)) // D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA
    If SD2->(DbSeek(xFilial("SD2") + cNumNF + cSerie + cCliente + cLoja))
        While SD2->(!Eof()) .And. SD2->D2_DOC == cNumNF .And. SD2->D2_SERIE == cSerie
            
            oItem := JsonObject():New()
            oItem['item'] := AllTrim(SD2->D2_ITEM)
            oItem['produto'] := AllTrim(SD2->D2_COD)
            oItem['descricao'] := AllTrim(Posicione("SB1", 1, xFilial("SB1") + SD2->D2_COD, "B1_DESC"))
            oItem['quantidade'] := SD2->D2_QUANT
            oItem['valorUnitario'] := SD2->D2_PRCVEN
            oItem['valorTotal'] := SD2->D2_TOTAL
            oItem['tes'] := AllTrim(SD2->D2_TES)
            oItem['cf'] := AllTrim(SD2->D2_CF)
            
            aAdd(aItens, oItem)
            
            SD2->(DbSkip())
        EndDo
    EndIf
    
    // Adiciona metadados
    oMeta['empresa'] := cEmpAnt
    oMeta['filial'] := cFilAnt
    oMeta['dataHoraEnvio'] := FWTimeStamp(3) // ISO 8601
    oMeta['usuario'] := __cUserID
    
    // Monta a estrutura que o middleware espera
    oNFData['key'] := AllTrim(cNumNF) + AllTrim(cSerie)
    oNFData['data'] := JsonObject():New()
    oNFData['data']['cabecalho'] := oCabec
    oNFData['data']['itens'] := aItens
    oNFData['data']['metadata'] := oMeta
    
    // Converte para string JSON
    cJson := oNFData:ToJson()
    
    // Envia para o Kafka com sistema de fallback
    lRet := oKafka:SendWithFallback(cJson)
    
    If lRet
        ConOut("[KAFKA] Nota Fiscal " + cNumNF + "/" + cSerie + " enviada com sucesso!")
        ConOut("[KAFKA] Broker utilizado: " + oKafka:GetUsedBroker())
        ConOut("[KAFKA] Offset: " + oKafka:GetOffset())
        U_LOGKAFKA(cNumNF, cSerie, "SUCCESS", "Enviado via " + oKafka:GetUsedBroker() + " - Offset: " + oKafka:GetOffset())
    Else
        ConOut("[KAFKA] ERRO: Falha ao enviar NF " + cNumNF + "/" + cSerie + " em todos os brokers!")
        ConOut("[KAFKA] Detalhes: " + oKafka:GetError())
        U_LOGKAFKA(cNumNF, cSerie, "ERROR", oKafka:GetError())
    EndIf
    
Return lRet

/*/{Protheus.doc} KafkaProducer
Classe para encapsular a comunicação com Kafka via REST API
Implementa sistema de fallback automático entre múltiplos brokers

@type Class
@author Fernando Vernier
@since 18/10/2025
@version 2.0 - FINAL
/*/
Class KafkaProducer
    Data aBrokers
    Data cTopic
    Data cError
    Data nTimeOut
    Data cUsedBroker
    Data cLastOffset
    
    Method New() Constructor
    Method Send(cJson, cBrokerUrl)
    Method SendWithFallback(cJson)
    Method GetError()
    Method GetUsedBroker()
    Method GetOffset()
    Method GetBrokers()
EndClass

Method New() Class KafkaProducer
    ::aBrokers := {}
    ::nTimeOut := GetMV("MV_KAFKATO",, 120)
    ::cError := ""
    ::cUsedBroker := ""
    ::cLastOffset := ""
    ::cTopic := AllTrim(GetMV("MV_KAFKATPC",, "protheus-notas-fiscais"))
    
    // Carrega os brokers do parâmetro ou usa os padrões
    ::aBrokers := ::GetBrokers()
    
Return Self

Method GetBrokers() Class KafkaProducer
    Local aBrokersConfig := {}
    Local cBrokers := AllTrim(GetMV("MV_KAFKABR",, ""))
    Local nI := 0
    
    // Se o parâmetro está vazio, usa os brokers padrão da empresa
    If Empty(cBrokers)
        aAdd(aBrokersConfig, "http://localhost:8081")
    Else
        // Se tem parâmetro, separa por vírgula
        aBrokersConfig := StrTokArr(cBrokers, ",")
        
        // Remove barras finais se houver
        For nI := 1 To Len(aBrokersConfig)
            aBrokersConfig[nI] := AllTrim(aBrokersConfig[nI])
            // Remove barra final
            While Right(aBrokersConfig[nI], 1) == "/"
                aBrokersConfig[nI] := SubStr(aBrokersConfig[nI], 1, Len(aBrokersConfig[nI])-1)
            EndDo
        Next nI
    EndIf
    
Return aBrokersConfig

Method SendWithFallback(cJson) Class KafkaProducer
    Local lRet := .F.
    Local nI := 0
    Local cBrokerUrl := ""
    Local aErrors := {}
    
    ConOut("[KAFKA] Iniciando tentativa de envio com fallback")
    ConOut("[KAFKA] Total de brokers configurados: " + cValToChar(Len(::aBrokers)))
    
    // Tenta enviar para cada broker na ordem
    For nI := 1 To Len(::aBrokers)
        cBrokerUrl := ::aBrokers[nI]
        
        ConOut("[KAFKA] Tentativa " + cValToChar(nI) + "/" + cValToChar(Len(::aBrokers)))
        ConOut("[KAFKA] Broker: " + cBrokerUrl)
        
        // Tenta enviar para o broker atual
        lRet := ::Send(cJson, cBrokerUrl)
        
        If lRet
            // Sucesso! Registra qual broker foi usado e sai do loop
            ::cUsedBroker := cBrokerUrl
            ConOut("[KAFKA] ✓ Sucesso no broker " + cValToChar(nI) + ": " + cBrokerUrl)
            Exit
        Else
            // Falhou, guarda o erro e tenta o próximo
            aAdd(aErrors, "Broker " + cValToChar(nI) + " (" + cBrokerUrl + "): " + ::cError)
            ConOut("[KAFKA] ✗ Falha no broker " + cValToChar(nI) + ": " + ::cError)
        EndIf
    Next nI
    
    // Se falhou em todos, monta mensagem com todos os erros
    If !lRet
        ::cError := "Falha em todos os brokers: " + CRLF
        For nI := 1 To Len(aErrors)
            ::cError += aErrors[nI]
            If nI < Len(aErrors)
                ::cError += CRLF
            EndIf
        Next nI
    EndIf
    
Return lRet

Method Send(cJson, cBrokerUrl) Class KafkaProducer
    Local lRet := .T.
    Local oRest := FWRest():New(cBrokerUrl)
    Local cResponse := ""
    Local oResponse := JsonObject():New()
    Local aHeader := {}
    Local cParseError := ""
    Local cPath := ""
    
    // Monta o path completo: /topics/nome-do-topico
    cPath := "/topics/" + ::cTopic
    
    // Configura headers necessários para Kafka REST Proxy
    aAdd(aHeader, "Content-Type: application/json")
    aAdd(aHeader, "Accept: application/json")
    
    // Configura o caminho
    oRest:setPath(cPath)
    
    // Define o body do POST
    oRest:SetPostParams(cJson)
    
    // Envia POST
    If oRest:Post(aHeader)
        cResponse := oRest:GetResult()
        
        // Tenta fazer parse da resposta
        cParseError := oResponse:FromJson(cResponse)
        
        If Empty(cParseError)
            // Verifica se tem o campo offsets (sucesso)
            If oResponse:HasProperty('offsets') .And. ValType(oResponse['offsets']) == "A"
                If Len(oResponse['offsets']) > 0
                    // Pega o offset retornado
                    If oResponse['offsets'][1]:HasProperty('offset')
                        ::cLastOffset := cValToChar(oResponse['offsets'][1]['offset'])
                        ConOut("[KAFKA] Offset: " + ::cLastOffset)
                    EndIf
                    
                    If oResponse['offsets'][1]:HasProperty('partition')
                        ConOut("[KAFKA] Partition: " + cValToChar(oResponse['offsets'][1]['partition']))
                    EndIf
                    
                    lRet := .T.
                    ::cError := ""
                Else
                    ::cError := "Resposta sem offsets"
                    lRet := .F.
                EndIf
            Else
                ::cError := "Resposta inválida - campo offsets não encontrado"
                lRet := .F.
            EndIf
        Else
            ::cError := "Erro ao fazer parse da resposta: " + cParseError
            lRet := .F.
        EndIf
    Else
        ::cError := "Erro HTTP: " + oRest:GetLastError()
        lRet := .F.
    EndIf
    
    // Libera o objeto
    FreeObj(oRest)
    
Return lRet

Method GetError() Class KafkaProducer
Return ::cError

Method GetUsedBroker() Class KafkaProducer
Return ::cUsedBroker

Method GetOffset() Class KafkaProducer
Return ::cLastOffset

/*/{Protheus.doc} U_LOGKAFKA
Função para registrar logs de integração (opcional)

@type User Function
@author Fernando Vernier
@since 18/10/2025

@param cNumNF, Character, Número da NF
@param cSerie, Character, Série
@param cStatus, Character, Status (SUCCESS/ERROR)
@param cMsg, Character, Mensagem
/*/
User Function LOGKAFKA(cNumNF, cSerie, cStatus, cMsg)
    Local cLog := "[LOG KAFKA] " + DtoC(Date()) + " " + Time() + " - "
    
    cLog += cNumNF + "/" + cSerie + " - " + cStatus + " - " + cMsg
    
    ConOut(cLog)
    
    // Aqui você pode implementar gravação em tabela customizada (ZZZ)
    // Exemplo:
    // RecLock("ZZZ", .T.)
    // ZZZ->ZZZ_FILIAL := xFilial("ZZZ")
    // ZZZ->ZZZ_DOC    := cNumNF
    // ZZZ->ZZZ_SERIE  := cSerie
    // ZZZ->ZZZ_STATUS := cStatus
    // ZZZ->ZZZ_MSG    := cMsg
    // ZZZ->ZZZ_DATA   := Date()
    // ZZZ->ZZZ_HORA   := Time()
    // ZZZ->ZZZ_OFFSET := SubStr(cMsg, At("Offset:", cMsg) + 8, 20)
    // MsUnlock()
    
Return

/*/{Protheus.doc} U_TESTKAFKA
Função para testar a integração com Kafka manualmente

@type User Function
@author Fernando Vernier
@since 18/10/2025
/*/
User Function TESTKAFKA()
    Local oKafka := KafkaProducer():New()
    Local oTest := JsonObject():New()
    Local cJson := ""
    Local lRet := .F.
    
    // Monta um JSON de teste no formato que o middleware espera
    oTest['key'] := 'TEST-' + DtoS(Date()) + "-" + StrTran(Time(), ":", "")
    oTest['data'] := JsonObject():New()
    oTest['data']['teste'] := .T.
    oTest['data']['mensagem'] := 'Teste de integração Protheus-Kafka'
    oTest['data']['dataHora'] := FWTimeStamp(3)
    oTest['data']['usuario'] := __cUserID
    oTest['data']['empresa'] := cEmpAnt
    oTest['data']['filial'] := cFilAnt
    
    cJson := oTest:ToJson()
    
    ConOut("[TESTE KAFKA] Iniciando teste de integração")
    ConOut("[TESTE KAFKA] JSON: " + cJson)
    
    lRet := oKafka:SendWithFallback(cJson)
    
    If lRet
        MsgInfo("Teste enviado com sucesso!" + CRLF + CRLF + ;
                "Broker utilizado: " + oKafka:GetUsedBroker() + CRLF + ;
                "Offset: " + oKafka:GetOffset(), ;
                "Teste Kafka - Sucesso")
    Else
        MsgStop("Falha no teste!" + CRLF + CRLF + ;
                "Erro: " + oKafka:GetError(), ;
                "Teste Kafka - Erro")
    EndIf
    
Return
